# Test_LestaG
 Test tasks for Lesta Games 
**********************************************************************

Файл содержит некоторые результаты работы программы и описание заданий
Проект состоит из файлов:

main.cpp - основной файл для запуска и тестирования функций
Functions.cpp - функции
FIFO.cpp - реализация циклических буферов

Автор: Михневич Анастасия Дмитриевна

**********************************************************************
Результаты работы программы:
1.
Enter an integer value:   123234
Number  123234  is even.
Vector: 
1
2
3
4
5
6
Array: 
10
20
30
40
50
60
Vector is empty: true
Array is full: false
Enter a size of array  :   6
Enter an integer array :   7 6 90 21 0 5
Sorted array: 0 5 6 7 21 90 

2.
Enter an integer value:   200
Number  200  is even.
Vector: 
1
2
3
4
5
6
Array: 
10
20
30
40
50
60
Vector is empty: true
Array is full: false
Enter a size of array  :   18
Enter an integer array :   374 3746 0 745 98457 1 6 0
8745 745 1 6 84597 322 886 0 0 0 0 0 0 0 
Sorted array: 0 0 0 0 0 1 1 6 6 322 374 745 745 886 3746 8745 84597 98457 

3.
Enter an integer value:   0
Number  0  is even.
Vector: 
1
2
3
4
5
6
Array: 
10
20
30
40
50
60
Vector is empty: true
Array is full: false
Enter a size of array  :   2
Enter an integer array :   01 10
Sorted array: 1 10 
**********************************
**********************************

Задание 1: 
  Алгоритм с использованием остатка от деления (пример из задания):
       Легок для чтения и понимания, интуитивный подход для решения задачи.
       В некоторых случаях может быть менее эффективным, ибо операция нахождения остатка от деления
      может быть более затратной по времени, чем побитовые операции.

  Алгоритм с использованием побитовой операции ( альтернативное решение задачи):
       На низком уровне данный тип операций быстрее, так как побитовые операции обычно оптимизируются компиляторами
      и выполняются быстрее, чем деление.
       В отличие от методов, использующих арифметические операции, метод с логическими операциями и работой с битами имеет
      меньшую читаемость для тех, кто не знаком с данными операциями.
       Метод может быть излишним для простых задач, где простота кода важнее производительности.

  Время выполнения обеих функций можно считать O(1), так как они выполняют фиксированное количество операций (независимо от значения входного числа).

Задание 2:
Сравнение реализаций.

 Полнота и качество реализации:

- CircularBufferArray:
  - Плюсы:
    - Простой и легкий код, без лишних зависимостей.
    - Явное управление памятью (предоставляет больше контроля над ресурсами).
  - Минусы:
    - Необходимость ручного управления памятью может привести к утечкам или ошибкам. Если забыть удалить динамически выделенный массив, это приведет к утечкам памяти.
- CircularBufferVector:
  - Плюсы:
    - Использует стандартную библиотеку, что облегчает управление памятью.
    - Позволяет автоматически подстраиваться под размер буфера, если это необходимо.
  - Минусы:
    - Более сложная структура данных может занимать больше памяти на малых буферах.
    - Если используются методы вектора, это может привести к дополнительным накладным расходам по сравнению с простым массивом.

 Оформление кода:

- Оба класса написаны просто и
читабельно, но реализация на основе std::vector делает код короче и нагляднее благодаря более высокоуровневому управлению памятью.
- Также std::vector обеспечивает более безопасный вариант работы с памятью, что делает его более предпочтительным.

 Сравнение быстродействия:

- CircularBufferArray:
  - Быстродействие: операции push и pop выполняются за O(1), так как требуется только обновление указателей и извлечение значения.
  - Поскольку используется статический массив, нет дополнительных накладных расходов на управление памятью.
 - CircularBufferVector:
  - Несмотря на потенциальные накладные расходы std::vector, в общем случае, для операций push и pop время выполнения все равно остается O(1).
  - Если размер буфера заранее известен и не изменяется, использование std::vector может быть избыточным, но если есть потребность в гибкости, этот вариант удобен.



Выбор между реализациями циклического буфера на основе статического массива
или std::vector зависит от конкретных требований проекта.

CircularBufferArray, если:
  - Ты ищешь максимальную производительность и контроль за памятью.
  - Твой размер буфера фиксирован и заранее известен.
  - Важно минимизировать использование стандартной библиотеки и накладные расходы.

CircularBufferVector, если:
  - Ты хочешь, чтобы управление памятью было более безопасным и удобным, не беспокоясь о явном освобождении ресурсов.
  - Потребности проекта могут изменяться, и гибкость является критически важной.
  - Ты уже используешь стандартную библиотеку и предпочитаешь удобство, предоставляемое контейнерами STL.


Задание 3:
 Для выполнения задания был выбран алгоритм быстрой сортировки(сортировка Хоара).
 Причины эффективности:
 Один из самых быстрых известных универсальных алгоритмов сортировки массивов.
 В большинстве случаев быстрая сортировка имеет временную сложность O(n log n), 
 что делает её быстрой даже для больших массивов.
 При правильно выбранном опорном элементе QuickSort часто показывает практически 
 линейный поиск времени выполнения даже в среднем.
 Если массив уже отсортирован — можно использовать другие методы для 
 избежания худшего случая (например, чтобы избежать O(n²)),
 но с применением оптимизаций, как использование рандомизации для выбора опорного элемента, 
 алгоритм может по-прежнему работать эффективно.
 Алгоритм требует мало дополнительной памяти. 
 С учетом стека вызовов рекурсии, его пространственная сложность составляет O(log n).
 
 Быстрая сортировка может быть не самым лучшим выбором для массивов, 
 состоящих из дубликатов, так как в худшем случае он может деградировать до O(n²).
 Но, если использовать оптимизации, такие как выбор медианы или использование метода трёх опор, можно решить эту проблему.

